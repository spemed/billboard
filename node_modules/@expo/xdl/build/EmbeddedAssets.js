"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureAsync = configureAsync;
exports.getEmbeddedManifestPath = getEmbeddedManifestPath;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function ExponentTools() {
  const data = _interopRequireWildcard(require("./detach/ExponentTools"));

  ExponentTools = function () {
    return data;
  };

  return data;
}

function IosPlist() {
  const data = _interopRequireWildcard(require("./detach/IosPlist"));

  IosPlist = function () {
    return data;
  };

  return data;
}

function IosWorkspace() {
  const data = _interopRequireWildcard(require("./detach/IosWorkspace"));

  IosWorkspace = function () {
    return data;
  };

  return data;
}

function _StandaloneContext() {
  const data = _interopRequireDefault(require("./detach/StandaloneContext"));

  _StandaloneContext = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _ArtifactUtils() {
  const data = require("./tools/ArtifactUtils");

  _ArtifactUtils = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore IosWorkspace not yet converted to TypeScript
async function configureAsync(config) {
  await _maybeWriteArtifactsToDiskAsync(config);
  await _maybeConfigureExpoKitEmbeddedAssetsAsync(config);
  await _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config);
}

function getEmbeddedManifestPath(platform, projectRoot, exp) {
  if (platform === 'ios') {
    return exp.ios && exp.ios.publishManifestPath ? exp.ios.publishManifestPath : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
  } else if (platform === 'android') {
    return exp.android && exp.android.publishManifestPath ? exp.android.publishManifestPath : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
  }

  return _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
}

function _getDefaultEmbeddedManifestPath(platform, projectRoot, exp) {
  return _path().default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.manifest');
}

function _getDefaultEmbeddedBundlePath(platform, projectRoot, exp) {
  return _path().default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.bundle');
}

function _getDefaultEmbeddedAssetDir(platform, projectRoot, exp) {
  if (platform === 'ios') {
    const context = _StandaloneContext().default.createUserContext(projectRoot, exp);

    const {
      supportingDirectory
    } = IosWorkspace().getPaths(context);
    return supportingDirectory;
  } else if (platform === 'android') {
    return _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'assets');
  } else {
    throw new Error('Embedding assets is not supported for platform ' + platform);
  }
}

async function _maybeWriteArtifactsToDiskAsync(config) {
  const {
    projectRoot,
    pkg,
    exp,
    iosManifest,
    iosBundle,
    iosSourceMap,
    androidManifest,
    androidBundle,
    androidSourceMap
  } = config;
  let androidBundlePath;
  let androidManifestPath;
  let androidSourceMapPath;
  let iosBundlePath;
  let iosManifestPath;
  let iosSourceMapPath; // set defaults for expo-updates

  if (pkg.dependencies['expo-updates'] && config.target !== 'managed') {
    const defaultAndroidDir = _getDefaultEmbeddedAssetDir('android', projectRoot, exp);

    const defaultIosDir = _getDefaultEmbeddedAssetDir('ios', projectRoot, exp);

    await _fsExtra().default.ensureDir(defaultIosDir);
    await _fsExtra().default.ensureDir(defaultAndroidDir);
    androidBundlePath = _getDefaultEmbeddedBundlePath('android', projectRoot, exp);
    androidManifestPath = _getDefaultEmbeddedManifestPath('android', projectRoot, exp);
    iosBundlePath = _getDefaultEmbeddedBundlePath('ios', projectRoot, exp);
    iosManifestPath = _getDefaultEmbeddedManifestPath('ios', projectRoot, exp);

    if (!_fsExtra().default.existsSync(iosBundlePath) || !_fsExtra().default.existsSync(iosManifestPath)) {
      _Logger().default.global.warn('Creating app.manifest and app.bundle inside of your ios/<project>/Supporting directory.\nBe sure to add these files to your Xcode project. More info at https://expo.fyi/embedded-assets');
    }
  } // allow custom overrides


  if (exp.android && exp.android.publishBundlePath) {
    androidBundlePath = exp.android.publishBundlePath;
  }

  if (exp.android && exp.android.publishManifestPath) {
    androidManifestPath = exp.android.publishManifestPath;
  }

  if (exp.android && exp.android.publishSourceMapPath) {
    androidSourceMapPath = exp.android.publishSourceMapPath;
  }

  if (exp.ios && exp.ios.publishBundlePath) {
    iosBundlePath = exp.ios.publishBundlePath;
  }

  if (exp.ios && exp.ios.publishManifestPath) {
    iosManifestPath = exp.ios.publishManifestPath;
  }

  if (exp.ios && exp.ios.publishSourceMapPath) {
    iosSourceMapPath = exp.ios.publishSourceMapPath;
  }

  if (androidBundlePath) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'android.publishBundlePath', androidBundlePath, androidBundle);
  }

  if (androidManifestPath) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'android.publishManifestPath', androidManifestPath, JSON.stringify(androidManifest));
  }

  if (androidSourceMapPath && androidSourceMap) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'android.publishSourceMapPath', androidSourceMapPath, androidSourceMap);
  }

  if (iosBundlePath) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'ios.publishBundlePath', iosBundlePath, iosBundle);
  }

  if (iosManifestPath) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'ios.publishManifestPath', iosManifestPath, JSON.stringify(iosManifest));
  }

  if (iosSourceMapPath && iosSourceMap) {
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, 'ios.publishSourceMapPath', iosSourceMapPath, iosSourceMap);
  }
}

async function _maybeConfigureExpoKitEmbeddedAssetsAsync(config) {
  const {
    projectRoot,
    exp,
    releaseChannel,
    androidManifestUrl,
    androidManifest
  } = config;

  const context = _StandaloneContext().default.createUserContext(projectRoot, exp);

  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context); // iOS ExpoKit

  if (releaseChannel && _fsExtra().default.existsSync(_path().default.join(supportingDirectory, 'EXShell.plist'))) {
    // This is an ExpoKit app, set properties in EXShell.plist
    await IosPlist().modifyAsync(supportingDirectory, 'EXShell', shellPlist => {
      shellPlist.releaseChannel = releaseChannel;
      return shellPlist;
    });
  } // Android ExpoKit


  let constantsPath = _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java');

  if (_fsExtra().default.existsSync(constantsPath)) {
    // This is an ExpoKit app
    // We need to add EmbeddedResponse instances on Android to tell the runtime
    // that the shell app manifest and bundle is packaged.
    await ExponentTools().deleteLinesInFileAsync(`START EMBEDDED RESPONSES`, `END EMBEDDED RESPONSES`, constantsPath);
    await ExponentTools().regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
      // ADD EMBEDDED RESPONSES HERE
      // START EMBEDDED RESPONSES
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifest.bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
      // END EMBEDDED RESPONSES`, constantsPath);

    if (releaseChannel) {
      await ExponentTools().regexFileAsync(/RELEASE_CHANNEL = "[^"]*"/, `RELEASE_CHANNEL = "${releaseChannel}"`, constantsPath);
    }
  }
}

async function _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config) {
  if (!config.pkg.dependencies['expo-updates'] || config.target === 'managed') {
    return;
  }

  const {
    projectRoot,
    exp,
    releaseChannel,
    iosManifestUrl,
    androidManifestUrl
  } = config;

  const context = _StandaloneContext().default.createUserContext(projectRoot, exp);

  const {
    supportingDirectory
  } = IosWorkspace().getPaths(context); // iOS expo-updates

  if (_fsExtra().default.existsSync(_path().default.join(supportingDirectory, 'Expo.plist'))) {
    // This is an app with expo-updates installed, set properties in Expo.plist
    await IosPlist().modifyAsync(supportingDirectory, 'Expo', configPlist => {
      configPlist.EXUpdatesURL = iosManifestUrl;
      configPlist.EXUpdatesSDKVersion = exp.sdkVersion;

      if (releaseChannel) {
        configPlist.EXUpdatesReleaseChannel = releaseChannel;
      }

      return configPlist;
    });
  } // Android expo-updates


  let androidManifestXmlPath = _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'AndroidManifest.xml');

  let androidManifestXmlFile = _fsExtra().default.readFileSync(androidManifestXmlPath, 'utf8');

  let expoUpdateUrlRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_UPDATE_URL"[^>]+\/>/;
  let expoSdkVersionRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_SDK_VERSION"[^>]+\/>/;
  let expoReleaseChannelRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_RELEASE_CHANNEL"[^>]+\/>/;
  let expoUpdateUrlTag = `<meta-data android:name="expo.modules.updates.EXPO_UPDATE_URL" android:value="${androidManifestUrl}" />`;
  let expoSdkVersionTag = `<meta-data android:name="expo.modules.updates.EXPO_SDK_VERSION" android:value="${exp.sdkVersion}" />`;
  let expoReleaseChannelTag = `<meta-data android:name="expo.modules.updates.EXPO_RELEASE_CHANNEL" android:value="${releaseChannel}" />`;
  let tagsToInsert = [];

  if (androidManifestXmlFile.search(expoUpdateUrlRegex) < 0) {
    tagsToInsert.push(expoUpdateUrlTag);
  }

  if (androidManifestXmlFile.search(expoSdkVersionRegex) < 0) {
    tagsToInsert.push(expoSdkVersionTag);
  }

  if (releaseChannel && androidManifestXmlFile.search(expoReleaseChannelRegex) < 0) {
    tagsToInsert.push(expoReleaseChannelTag);
  }

  if (tagsToInsert.length) {
    // try to insert the meta-data tags that aren't found
    await ExponentTools().regexFileAsync(/<activity\s+android:name=".MainActivity"/, `${tagsToInsert.join('\n      ')}

  <activity
    android:name=".MainActivity"`, androidManifestXmlPath);
  }

  await ExponentTools().regexFileAsync(expoUpdateUrlRegex, expoUpdateUrlTag, androidManifestXmlPath);
  await ExponentTools().regexFileAsync(expoSdkVersionRegex, expoSdkVersionTag, androidManifestXmlPath);

  if (releaseChannel) {
    await ExponentTools().regexFileAsync(expoReleaseChannelRegex, expoReleaseChannelTag, androidManifestXmlPath);
  }
}
//# sourceMappingURL=__sourcemaps__/EmbeddedAssets.js.map
