"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const child_process_1 = require("child_process");
const jest_message_util_1 = require("jest-message-util");
const Errors_1 = require("./Errors");
const Modules_1 = require("./Modules");
const Serialize_1 = require("./Serialize");
function isMissingFileCode(code) {
    return ['ENOENT', 'MODULE_NOT_FOUND', 'ENOTDIR'].includes(code);
}
function readConfigFile(configFilePath, context) {
    if (!Modules_1.fileExists(configFilePath))
        return null;
    try {
        return evalConfig(configFilePath, context);
    }
    catch (error) {
        // If the file doesn't exist then we should skip it and continue searching.
        if (!isMissingFileCode(error.code)) {
            throw error;
        }
    }
    return null;
}
function getDynamicConfig(configPath, request) {
    const config = readConfigFile(configPath, request);
    if (config) {
        return Serialize_1.serializeAndEvaluate(config);
    }
    throw new Errors_1.ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');
}
exports.getDynamicConfig = getDynamicConfig;
function getStaticConfig(configPath) {
    const config = json_file_1.default.read(configPath, { json5: true });
    if (config) {
        return Serialize_1.serializeAndEvaluate(config);
    }
    throw new Errors_1.ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');
}
exports.getStaticConfig = getStaticConfig;
// We cannot use async config resolution right now because Next.js doesn't support async configs.
// If they don't add support for async Webpack configs then we may need to pull support for Next.js.
function evalConfig(configFile, request) {
    try {
        const spawnResults = child_process_1.spawnSync('node', [
            require.resolve('@expo/config/build/scripts/read-config.js'),
            '--colors',
            configFile,
            JSON.stringify(Object.assign(Object.assign({}, request), { config: Serialize_1.serializeAndEvaluate(request.config) })),
        ], {});
        if (spawnResults.status === 0) {
            const spawnResultString = spawnResults.stdout.toString('utf8').trim();
            const logs = spawnResultString.split('\n');
            // Get the last console log to prevent parsing anything logged in the config.
            const lastLog = logs.pop();
            for (const log of logs) {
                // Log out the logs from the config
                console.log(log);
            }
            // Parse the final log of the script, it's the serialized config
            return JSON.parse(lastLog);
        }
        else {
            // Parse the error data and throw it as expected
            const errorData = JSON.parse(spawnResults.stderr.toString('utf8'));
            throw Errors_1.errorFromJSON(errorData);
        }
    }
    catch (error) {
        if (isMissingFileCode(error.code) || !(error instanceof SyntaxError)) {
            throw error;
        }
        const message = jest_message_util_1.formatExecError(error, { rootDir: request.projectRoot, testMatch: [] }, { noStackTrace: true }, undefined, true);
        throw new Errors_1.ConfigError(`\n${message}`, 'INVALID_CONFIG');
    }
}
//# sourceMappingURL=getConfig.js.map