"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const path_1 = __importDefault(require("path"));
const slugify_1 = __importDefault(require("slugify"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const globby_1 = __importDefault(require("globby"));
const semver_1 = __importDefault(require("semver"));
const Errors_1 = require("./Errors");
const getConfig_1 = require("./getConfig");
const Modules_1 = require("./Modules");
const Project_1 = require("./Project");
function reduceExpoObject(config) {
    if (!config)
        return config === undefined ? null : config;
    if (typeof config.expo === 'object') {
        // TODO: We should warn users in the future that if there are more values than "expo", those values outside of "expo" will be omitted in favor of the "expo" object.
        return config.expo;
    }
    return config;
}
/**
 * Get all platforms that a project is currently capable of running.
 *
 * @param projectRoot
 * @param exp
 */
function getSupportedPlatforms(projectRoot, exp) {
    const platforms = [];
    if (Modules_1.projectHasModule('react-native', projectRoot, exp)) {
        platforms.push('ios', 'android');
    }
    if (Modules_1.projectHasModule('react-native-web', projectRoot, exp)) {
        platforms.push('web');
    }
    return platforms;
}
/**
 * Evaluate the config for an Expo project.
 * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.
 * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.
 *
 *
 * **Example**
 * ```js
 * module.exports = function({ config }) {
 *   // mutate the config before returning it.
 *   config.slug = 'new slug'
 *   return config;
 * }
 *
 * **Supports**
 * - `app.config.ts`
 * - `app.config.js`
 * - `app.config.json`
 * - `app.json`
 *
 * @param projectRoot the root folder containing all of your application code
 * @param options enforce criteria for a project config
 */
function getConfig(projectRoot, options = {}) {
    const paths = getConfigFilePaths(projectRoot);
    const rawStaticConfig = paths.staticConfigPath ? getConfig_1.getStaticConfig(paths.staticConfigPath) : null;
    // For legacy reasons, always return an object.
    const rootConfig = (rawStaticConfig || {});
    const staticConfig = reduceExpoObject(rawStaticConfig) || {};
    const jsonFileWithNodeModulesPath = reduceExpoObject(rootConfig);
    // Can only change the package.json location if an app.json or app.config.json exists with nodeModulesPath
    const [packageJson, packageJsonPath] = getPackageJsonAndPath(projectRoot, jsonFileWithNodeModulesPath);
    function fillAndReturnConfig(config) {
        return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, config, packageJson, options.skipSDKVersionRequirement)), { rootConfig, dynamicConfigPath: paths.dynamicConfigPath, staticConfigPath: paths.staticConfigPath });
    }
    // Fill in the static config
    function getContextConfig(config = {}) {
        return ensureConfigHasDefaultValues(projectRoot, config, packageJson, true).exp;
    }
    if (paths.dynamicConfigPath) {
        // No app.config.json or app.json but app.config.js
        const rawDynamicConfig = getConfig_1.getDynamicConfig(paths.dynamicConfigPath, {
            projectRoot,
            staticConfigPath: paths.staticConfigPath,
            packageJsonPath,
            config: getContextConfig(staticConfig),
        });
        // Allow for the app.config.js to `export default null;`
        // Use `dynamicConfigPath` to detect if a dynamic config exists.
        const dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};
        return fillAndReturnConfig(dynamicConfig);
    }
    // No app.config.js but json or no config
    return fillAndReturnConfig(staticConfig || {});
}
exports.getConfig = getConfig;
function getPackageJson(projectRoot, config = {}) {
    const [pkg] = getPackageJsonAndPath(projectRoot, config);
    return pkg;
}
exports.getPackageJson = getPackageJson;
function getPackageJsonAndPath(projectRoot, config = {}) {
    const packageJsonPath = Modules_1.getRootPackageJsonPath(projectRoot, config);
    return [json_file_1.default.read(packageJsonPath), packageJsonPath];
}
function readConfigJson(projectRoot, skipValidation = false, skipNativeValidation = false) {
    const paths = getConfigFilePaths(projectRoot);
    const rawStaticConfig = paths.staticConfigPath ? getConfig_1.getStaticConfig(paths.staticConfigPath) : null;
    const getConfigName = () => {
        if (paths.staticConfigPath)
            ` \`${path_1.default.basename(paths.staticConfigPath)}\``;
        return '';
    };
    let outputRootConfig = rawStaticConfig;
    if (outputRootConfig === null || typeof outputRootConfig !== 'object') {
        if (skipValidation) {
            outputRootConfig = { expo: {} };
        }
        else {
            throw new Errors_1.ConfigError(`Project at path ${path_1.default.resolve(projectRoot)} does not contain a valid Expo config${getConfigName()}`, 'NOT_OBJECT');
        }
    }
    let exp = outputRootConfig.expo;
    if (exp === null || typeof exp !== 'object') {
        throw new Errors_1.ConfigError(`Property 'expo' in${getConfigName()} for project at path ${path_1.default.resolve(projectRoot)} is not an object. Please make sure${getConfigName()} includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`, 'NO_EXPO');
    }
    exp = Object.assign({}, exp);
    const [pkg] = getPackageJsonAndPath(projectRoot, exp);
    return Object.assign(Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation)), { dynamicConfigPath: null, rootConfig: Object.assign({}, outputRootConfig) }), paths);
}
exports.readConfigJson = readConfigJson;
function readConfigJsonAsync(projectRoot, skipValidation = false, skipNativeValidation = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return readConfigJson(projectRoot, skipValidation, skipNativeValidation);
    });
}
exports.readConfigJsonAsync = readConfigJsonAsync;
/**
 * Get the static and dynamic config paths for a project. Also accounts for custom paths.
 *
 * @param projectRoot
 */
function getConfigFilePaths(projectRoot) {
    const customPaths = getCustomConfigFilePaths(projectRoot);
    if (customPaths) {
        return customPaths;
    }
    return {
        dynamicConfigPath: getDynamicConfigFilePath(projectRoot),
        staticConfigPath: getStaticConfigFilePath(projectRoot),
    };
}
exports.getConfigFilePaths = getConfigFilePaths;
function getCustomConfigFilePaths(projectRoot) {
    if (!customConfigPaths[projectRoot]) {
        return null;
    }
    // If the user picks a custom config path, we will only use that and skip searching for a secondary config.
    if (isDynamicFilePath(customConfigPaths[projectRoot])) {
        return {
            dynamicConfigPath: customConfigPaths[projectRoot],
            staticConfigPath: null,
        };
    }
    // Anything that's not js or ts will be treated as json.
    return { staticConfigPath: customConfigPaths[projectRoot], dynamicConfigPath: null };
}
function getDynamicConfigFilePath(projectRoot) {
    for (const fileName of ['app.config.ts', 'app.config.js']) {
        const configPath = path_1.default.join(projectRoot, fileName);
        if (fs_extra_1.default.existsSync(configPath)) {
            return configPath;
        }
    }
    return null;
}
function getStaticConfigFilePath(projectRoot) {
    for (const fileName of ['app.config.json', 'app.json']) {
        const configPath = path_1.default.join(projectRoot, fileName);
        if (fs_extra_1.default.existsSync(configPath)) {
            return configPath;
        }
    }
    return null;
}
// TODO: This should account for dynamic configs
function findConfigFile(projectRoot) {
    let configPath;
    // Check for a custom config path first.
    if (customConfigPaths[projectRoot]) {
        configPath = customConfigPaths[projectRoot];
        // We shouldn't verify if the file exists because
        // the user manually specified that this path should be used.
        return {
            configPath,
            configName: path_1.default.basename(configPath),
            configNamespace: 'expo',
        };
    }
    else {
        // app.config.json takes higher priority over app.json
        configPath = path_1.default.join(projectRoot, 'app.config.json');
        if (!fs_extra_1.default.existsSync(configPath)) {
            configPath = path_1.default.join(projectRoot, 'app.json');
        }
    }
    return {
        configPath,
        configName: path_1.default.basename(configPath),
        configNamespace: 'expo',
    };
}
exports.findConfigFile = findConfigFile;
// TODO: deprecate
function configFilename(projectRoot) {
    return findConfigFile(projectRoot).configName;
}
exports.configFilename = configFilename;
function readExpRcAsync(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const expRcPath = path_1.default.join(projectRoot, '.exprc');
        return yield json_file_1.default.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });
    });
}
exports.readExpRcAsync = readExpRcAsync;
const customConfigPaths = {};
function setCustomConfigPath(projectRoot, configPath) {
    customConfigPaths[projectRoot] = configPath;
}
exports.setCustomConfigPath = setCustomConfigPath;
const APP_JSON_EXAMPLE = JSON.stringify({
    expo: {
        name: 'My app',
        slug: 'my-app',
        sdkVersion: '...',
    },
});
function parseAndValidateRootConfig(rootConfig, configName, skipValidation, projectRoot) {
    let outputRootConfig = rootConfig;
    if (outputRootConfig === null || typeof outputRootConfig !== 'object') {
        if (skipValidation) {
            outputRootConfig = { expo: {} };
        }
        else {
            throw new Errors_1.ConfigError(`Project at path ${path_1.default.resolve(projectRoot)} does not contain a valid Expo config (${configName}).`, 'NOT_OBJECT');
        }
    }
    const exp = outputRootConfig.expo;
    if (exp === null || typeof exp !== 'object') {
        throw new Errors_1.ConfigError(`Property 'expo' in \`${configName}\` for project at path ${path_1.default.resolve(projectRoot)} is not an object. Please make sure \`${configName}\` includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`, 'NO_EXPO');
    }
    return {
        // Spread object to ensure they aren't mutable.
        // TODO: Maybe this should be a deep clone.
        exp: Object.assign({}, exp),
        rootConfig: Object.assign({}, outputRootConfig),
    };
}
function ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipSDKVersionRequirement = false) {
    if (!exp)
        exp = {};
    if (!exp.name) {
        if (typeof pkg.name !== 'string') {
            pkg.name = path_1.default.basename(projectRoot);
        }
        exp.name = pkg.name;
    }
    if (!exp.description && typeof pkg.description === 'string') {
        exp.description = pkg.description;
    }
    if (!exp.slug && typeof exp.name === 'string') {
        exp.slug = slugify_1.default(exp.name.toLowerCase());
    }
    if (!exp.version) {
        if (typeof pkg.version === 'string') {
            exp.version = pkg.version;
        }
        else {
            pkg.version = '1.0.0';
        }
        exp.version = pkg.version;
    }
    if (exp.nodeModulesPath) {
        exp.nodeModulesPath = path_1.default.resolve(projectRoot, exp.nodeModulesPath);
    }
    try {
        exp.sdkVersion = Project_1.getExpoSDKVersion(projectRoot, exp);
    }
    catch (error) {
        if (!skipSDKVersionRequirement)
            throw error;
    }
    if (!exp.platforms) {
        exp.platforms = getSupportedPlatforms(projectRoot, exp);
    }
    return { exp, pkg };
}
function writeConfigJsonAsync(projectRoot, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = getConfigFilePaths(projectRoot);
        let { exp, pkg, rootConfig, staticConfigPath } = yield readConfigJsonAsync(projectRoot);
        exp = Object.assign(Object.assign({}, rootConfig.expo), options);
        rootConfig = Object.assign(Object.assign({}, rootConfig), { expo: exp });
        if (paths.staticConfigPath) {
            yield json_file_1.default.writeAsync(paths.staticConfigPath, rootConfig, { json5: false });
        }
        else {
            console.log('Failed to write to config: ', options);
        }
        return Object.assign({ exp,
            pkg,
            rootConfig,
            staticConfigPath }, paths);
    });
}
exports.writeConfigJsonAsync = writeConfigJsonAsync;
const DEFAULT_BUILD_PATH = `web-build`;
function getWebOutputPath(config = {}) {
    var _a, _b, _c;
    if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {
        return process.env.WEBPACK_BUILD_OUTPUT_PATH;
    }
    const expo = config.expo || config || {};
    return ((_c = (_b = (_a = expo) === null || _a === void 0 ? void 0 : _a.web) === null || _b === void 0 ? void 0 : _b.build) === null || _c === void 0 ? void 0 : _c.output) || DEFAULT_BUILD_PATH;
}
exports.getWebOutputPath = getWebOutputPath;
function getNameFromConfig(exp = {}) {
    // For RN CLI support
    const appManifest = exp.expo || exp;
    const { web = {} } = appManifest;
    // rn-cli apps use a displayName value as well.
    const appName = exp.displayName || appManifest.displayName || appManifest.name;
    const webName = web.name || appName;
    return {
        appName,
        webName,
    };
}
exports.getNameFromConfig = getNameFromConfig;
function getDefaultTarget(projectRoot) {
    const { exp } = getConfig(projectRoot, { skipSDKVersionRequirement: true });
    // before SDK 37, always default to managed to preserve previous behavior
    if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver_1.default.lt(exp.sdkVersion, '37.0.0')) {
        return 'managed';
    }
    return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';
}
exports.getDefaultTarget = getDefaultTarget;
function isBareWorkflowProject(projectRoot) {
    const { pkg } = getConfig(projectRoot, {
        skipSDKVersionRequirement: true,
    });
    if (pkg.dependencies && pkg.dependencies.expokit) {
        return false;
    }
    if (fs_extra_1.default.existsSync(path_1.default.resolve(projectRoot, 'ios'))) {
        const xcodeprojFiles = globby_1.default.sync([path_1.default.join(projectRoot, 'ios', '/**/*.xcodeproj')]);
        if (xcodeprojFiles.length) {
            return true;
        }
    }
    if (fs_extra_1.default.existsSync(path_1.default.resolve(projectRoot, 'android'))) {
        const gradleFiles = globby_1.default.sync([path_1.default.join(projectRoot, 'android', '/**/*.gradle')]);
        if (gradleFiles.length) {
            return true;
        }
    }
    return false;
}
/**
 * true if the file is .js or .ts
 *
 * @param filePath
 */
function isDynamicFilePath(filePath) {
    return !!filePath.match(/\.[j|t]s$/);
}
//# sourceMappingURL=Config.js.map