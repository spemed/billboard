"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ejectAsync = ejectAsync;
exports.stripDashes = stripDashes;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _npmPackageArg() {
  const data = _interopRequireDefault(require("npm-package-arg"));

  _npmPackageArg = function () {
    return data;
  };

  return data;
}

function _pacote() {
  const data = _interopRequireDefault(require("pacote"));

  _pacote = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _tempy() {
  const data = _interopRequireDefault(require("tempy"));

  _tempy = function () {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function PackageManager() {
  const data = _interopRequireWildcard(require("@expo/package-manager"));

  PackageManager = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _configureIOSProjectAsync() {
  const data = _interopRequireDefault(require("../apply/configureIOSProjectAsync"));

  _configureIOSProjectAsync = function () {
    return data;
  };

  return data;
}

function _configureAndroidProjectAsync() {
  const data = _interopRequireDefault(require("../apply/configureAndroidProjectAsync"));

  _configureAndroidProjectAsync = function () {
    return data;
  };

  return data;
}

function _logConfigWarnings() {
  const data = require("../utils/logConfigWarnings");

  _logConfigWarnings = function () {
    return data;
  };

  return data;
}

function _maybeBailOnGitStatusAsync() {
  const data = _interopRequireDefault(require("../utils/maybeBailOnGitStatusAsync"));

  _maybeBailOnGitStatusAsync = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EXPO_APP_ENTRY = 'node_modules/expo/AppEntry.js';
/**
 * Entry point into the eject process, delegates to other helpers to perform various steps.
 */

async function ejectAsync(projectRoot, options) {
  if (await (0, _maybeBailOnGitStatusAsync().default)()) return;
  await createNativeProjectsFromTemplateAsync(projectRoot);
  await installNodeModulesAsync(projectRoot);
  await configureIOSStepAsync(projectRoot);
  await configureAndroidStepAsync(projectRoot);
  let podsInstalled = await installPodsAsync(projectRoot);
  await warnIfDependenciesRequireAdditionalSetupAsync(projectRoot);

  _log().default.newLine();

  _log().default.nested(`‚û°Ô∏è  ${_chalk().default.bold('Next steps')}`);

  _log().default.nested(`- üëÜ Review the logs above and look for any warnings (‚ö†Ô∏è ) that might need follow-up.`);

  _log().default.nested(`- üí° You may want to run ${_chalk().default.bold('npx @react-native-community/cli doctor')} to help install any tools that your app may need to run your native projects.`);

  if (!podsInstalled) {
    _log().default.nested(`- üç´ When CocoaPods is installed, initialize the project workspace: ${_chalk().default.bold('cd ios && pod install')}`);
  }

  _log().default.nested(`- üîë Download your Android keystore (if you're not sure if you need to, just run the command and see): ${_chalk().default.bold('expo fetch:android:keystore')}`);

  _log().default.newLine();

  _log().default.nested(`‚òëÔ∏è  ${_chalk().default.bold('When you are ready to run your project')}`);

  _log().default.nested('To compile and run your project, execute one of the following commands:');

  let packageManager = (0, _config().isUsingYarn)(projectRoot) ? 'yarn' : 'npm';

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run ios' : 'yarn ios')}`);

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run android' : 'yarn android')}`);

  _log().default.nested(`- ${_chalk().default.bold(packageManager === 'npm' ? 'npm run web' : 'yarn web')}`);
}

async function configureIOSStepAsync(projectRoot) {
  _log().default.newLine();

  let applyingIOSConfigStep = logNewSection('Applying iOS configuration');
  await (0, _configureIOSProjectAsync().default)(projectRoot);

  if (_config().WarningAggregator.hasWarningsIOS()) {
    applyingIOSConfigStep.stopAndPersist({
      symbol: '‚ö†Ô∏è ',
      text: _chalk().default.red('iOS configuration applied with warnings that should be fixed:')
    });
    (0, _logConfigWarnings().logConfigWarningsIOS)();
  } else {
    applyingIOSConfigStep.succeed('All project configuration applied to iOS project');
  }

  _log().default.newLine();
}

async function installPodsAsync(projectRoot) {
  _log().default.newLine();

  let step = logNewSection('Installing CocoaPods.');

  if (process.platform !== 'darwin') {
    step.succeed('Skipped installing CocoaPods because operating system is not on macOS.');
    return false;
  }

  const packageManager = new (PackageManager().CocoaPodsPackageManager)({
    cwd: _path().default.join(projectRoot, 'ios'),
    log: _log().default,
    silent: !process.env.EXPO_DEBUG
  });

  if (!(await packageManager.isCLIInstalledAsync())) {
    try {
      // prompt user -- do you want to install cocoapods right now?
      step.text = 'CocoaPods CLI not found in your PATH, installing it now.';
      step.render();
      await packageManager.installCLIAsync();
      step.succeed('Installed CocoaPods CLI');
      step = logNewSection('Running `pod install` in the `ios` directory.');
    } catch (e) {
      step.stopAndPersist({
        symbol: '‚ö†Ô∏è ',
        text: _chalk().default.red('Unable to install the CocoaPods CLI. Continuing with ejecting, you can install CocoaPods afterwards.')
      });

      if (e.message) {
        (0, _log().default)(`- ${e.message}`);
      }

      return false;
    }
  }

  try {
    await packageManager.installAsync();
    step.succeed('Installed pods and initialized Xcode workspace.');
    return true;
  } catch (e) {
    step.stopAndPersist({
      symbol: '‚ö†Ô∏è ',
      text: _chalk().default.red('Something when wrong running `pod install` in the `ios` directory. Continuing with ejecting, you can debug this afterwards.')
    });

    if (e.message) {
      (0, _log().default)(`- ${e.message}`);
    }

    return false;
  }
}

async function installNodeModulesAsync(projectRoot) {
  let installingDependenciesStep = logNewSection('Installing JavaScript dependencies.');
  await _fsExtra().default.remove('node_modules');
  const packageManager = PackageManager().createForProject(projectRoot, {
    log: _log().default,
    silent: true
  });

  try {
    await packageManager.installAsync();
    installingDependenciesStep.succeed('Installed JavaScript dependencies.');
  } catch (e) {
    // It doesn't matter for the rest of the process if this fails because the other steps can handle it gracefully.
    // CocoaPods will fail to install but otherwise things will work fine.
    installingDependenciesStep.fail('Something when wrong installing dependencies, check your package manager logfile. Continuing with ejecting, you can debug this afterwards.');
  }
}

async function configureAndroidStepAsync(projectRoot) {
  let applyingAndroidConfigStep = logNewSection('Applying Android configuration');
  await (0, _configureAndroidProjectAsync().default)(projectRoot);

  if (_config().WarningAggregator.hasWarningsAndroid()) {
    applyingAndroidConfigStep.stopAndPersist({
      symbol: '‚ö†Ô∏è ',
      text: _chalk().default.red('Android configuration applied with warnings that should be fixed:')
    });
    (0, _logConfigWarnings().logConfigWarningsAndroid)();
  } else {
    applyingAndroidConfigStep.succeed('All project configuration applied to Android project');
  }
}

function logNewSection(title) {
  let spinner = (0, _ora().default)(_chalk().default.bold(title));
  spinner.start();
  return spinner;
}

async function createNativeProjectsFromTemplateAsync(projectRoot) {
  var _appJson$expo, _appJson$expo$ios, _appJson$expo$android;

  // We need the SDK version to proceed
  const {
    exp,
    pkg
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });

  if (!exp.sdkVersion) {
    throw new Error(`Unable to find the project's SDK version. Are you in the correct directory?`);
  } // Validate that the template exists


  let sdkMajorVersionNumber = _semver().default.major(exp.sdkVersion);

  let templateSpec = (0, _npmPackageArg().default)(`expo-template-bare-minimum@sdk-${sdkMajorVersionNumber}`);

  try {
    await _pacote().default.manifest(templateSpec);
  } catch (e) {
    if (e.code === 'E404') {
      throw new Error(`Unable to eject because an eject template for SDK ${sdkMajorVersionNumber} was not found.`);
    } else {
      throw e;
    }
  }
  /**
   * Set names to be used for the native projects and configure appEntry so users can continue
   * to use Expo client on ejected projects, even though we change the "main" to index.js for bare.
   *
   * TODO: app.config.js will become more prominent and we can't depend on
   * being able to write to the config
   */


  const {
    configPath,
    configName
  } = (0, _config().findConfigFile)(projectRoot);
  const configBuffer = await _fsExtra().default.readFile(configPath);
  const appJson = configName === 'app.json' ? JSON.parse(configBuffer.toString()) : {}; // Just to be sure

  appJson.expo = (_appJson$expo = appJson.expo) !== null && _appJson$expo !== void 0 ? _appJson$expo : {};
  let name = await promptForNativeAppNameAsync(projectRoot);
  appJson.expo.name = name;
  let bundleIdentifier = await getOrPromptForBundleIdentifier(projectRoot);
  appJson.expo.ios = (_appJson$expo$ios = appJson.expo.ios) !== null && _appJson$expo$ios !== void 0 ? _appJson$expo$ios : {};
  appJson.expo.ios.bundleIdentifier = bundleIdentifier;
  let packageName = await getOrPromptForPackage(projectRoot);
  appJson.expo.android = (_appJson$expo$android = appJson.expo.android) !== null && _appJson$expo$android !== void 0 ? _appJson$expo$android : {};
  appJson.expo.android.package = packageName; // TODO: remove entryPoint and log about it for sdk 37 changes

  if (appJson.expo.entryPoint && appJson.expo.entryPoint !== EXPO_APP_ENTRY) {
    (0, _log().default)(`- expo.entryPoint is already configured, we recommend using "${EXPO_APP_ENTRY}`);
  } else {
    appJson.expo.entryPoint = EXPO_APP_ENTRY;
  }

  let updatingAppConfigStep = logNewSection('Updating app configuration (app.json)');
  await _fsExtra().default.writeFile(_path().default.resolve('app.json'), JSON.stringify(appJson, null, 2)); // TODO: if app.config.js, need to provide some other info here

  updatingAppConfigStep.succeed('App configuration (app.json) updated.');
  /**
   * Extract the template and copy the ios and android directories over to the project directory
   */

  let defaultDependencies = {};
  let defaultDevDependencies = {}; // NOTE(brentvatne): Removing spaces between steps for now, add back when
  // there is some additioanl context for steps
  // log.newLine();

  let creatingNativeProjectStep = logNewSection('Creating native project directories (./ios and ./android) and updating .gitignore');

  try {
    const tempDir = _tempy().default.directory();

    await _xdl().Exp.extractTemplateAppAsync(templateSpec, tempDir, appJson.expo);

    _fsExtra().default.copySync(_path().default.join(tempDir, 'ios'), _path().default.join(projectRoot, 'ios'));

    _fsExtra().default.copySync(_path().default.join(tempDir, 'android'), _path().default.join(projectRoot, 'android'));

    _fsExtra().default.copySync(_path().default.join(tempDir, 'index.js'), _path().default.join(projectRoot, 'index.js'));

    await mergeGitIgnoreAsync(_path().default.join(projectRoot, '.gitignore'), _path().default.join(tempDir, '.gitignore'));

    const {
      dependencies,
      devDependencies
    } = _jsonFile().default.read(_path().default.join(tempDir, 'package.json'));

    defaultDependencies = createDependenciesMap(dependencies);
    defaultDevDependencies = createDependenciesMap(devDependencies);
    creatingNativeProjectStep.succeed('Created native project directories (./ios and ./android) and updated .gitignore.');
  } catch (e) {
    (0, _log().default)(_chalk().default.red(e.message));
    creatingNativeProjectStep.fail('Failed to create the native project - see the output above for more information.');
    (0, _log().default)(_chalk().default.yellow('You may want to delete the `./ios` and/or `./android` directories before running eject again.'));
    process.exit(1);
  }
  /**
   * Update package.json scripts - `npm start` should default to `react-native
   * start` rather than `expo start` after ejecting, for example.
   */
  // NOTE(brentvatne): Removing spaces between steps for now, add back when
  // there is some additioanl context for steps
  // log.newLine();


  let updatingPackageJsonStep = logNewSection('Updating your package.json scripts, dependencies, and main file');

  if (!pkg.scripts) {
    pkg.scripts = {};
  }

  delete pkg.scripts.eject;
  pkg.scripts.start = 'react-native start';
  pkg.scripts.ios = 'react-native run-ios';
  pkg.scripts.android = 'react-native run-android';
  /**
   * Update package.json dependencies by combining the dependencies in the project we are ejecting
   * with the dependencies in the template project. Does the same for devDependencies.
   *
   * - The template may have some dependencies beyond react/react-native/react-native-unimodules,
   *   for example RNGH and Reanimated. We should prefer the version that is already being used
   *   in the project for those, but swap the react/react-native/react-native-unimodules versions
   *   with the ones in the template.
   */

  const combinedDependencies = createDependenciesMap({ ...defaultDependencies,
    ...pkg.dependencies
  });

  for (const dependenciesKey of ['react', 'react-native-unimodules', 'react-native']) {
    combinedDependencies[dependenciesKey] = defaultDependencies[dependenciesKey];
  }

  const combinedDevDependencies = createDependenciesMap({ ...defaultDevDependencies,
    ...pkg.devDependencies
  }); // Jetifier is only needed for SDK 34 & 35

  if (_xdl().Versions.lteSdkVersion(exp, '35.0.0')) {
    combinedDevDependencies['jetifier'] = defaultDevDependencies['jetifier'];
  } // Save the dependencies


  pkg.dependencies = combinedDependencies;
  pkg.devDependencies = combinedDevDependencies;
  await _fsExtra().default.writeFile(_path().default.resolve('package.json'), JSON.stringify(pkg, null, 2));
  /**
   * Add new app entry points
   */

  let removedPkgMain;

  if (pkg.main !== EXPO_APP_ENTRY && pkg.main) {
    removedPkgMain = pkg.main;
  }

  delete pkg.main;
  await _fsExtra().default.writeFile(_path().default.resolve('package.json'), JSON.stringify(pkg, null, 2));
  updatingPackageJsonStep.succeed('Updated package.json and added index.js entry point for iOS and Android.');

  if (removedPkgMain) {
    (0, _log().default)(`- Removed ${_chalk().default.bold(`"main": "${removedPkgMain}"`)} from package.json because we recommend using index.js as main instead.`);

    _log().default.newLine();
  }
}
/**
 * Create an object of type DependenciesMap a dependencies object or throw if not valid.
 *
 * @param dependencies - ideally an object of type {[key]: string} - if not then this will error.
 */


function createDependenciesMap(dependencies) {
  if (typeof dependencies !== 'object') {
    throw new Error(`Dependency map is invalid, expected object but got ${typeof dependencies}`);
  }

  const outputMap = {};
  if (!dependencies) return outputMap;

  for (const key of Object.keys(dependencies)) {
    const value = dependencies[key];

    if (typeof value === 'string') {
      outputMap[key] = value;
    } else {
      throw new Error(`Dependency for key \`${key}\` should be a \`string\`, instead got: \`{ ${key}: ${JSON.stringify(value)} }\``);
    }
  }

  return outputMap;
}

async function promptForNativeAppNameAsync(projectRoot) {
  const {
    exp
  } = await (0, _config().readConfigJsonAsync)(projectRoot);
  let {
    name
  } = exp;

  if (!name) {
    (0, _log().default)('First, we want to clarify what names we should use for your app:');
    ({
      name
    } = await (0, _prompt().default)([{
      name: 'name',
      message: "What should your app appear as on a user's home screen?",
      default: exp.name,

      validate({
        length
      }) {
        return length ? true : 'App display name cannot be empty.';
      }

    }], {
      nonInteractiveHelp: 'Please specify "expo.name" in app.json / app.config.js.'
    }));

    _log().default.newLine();
  }

  return name;
}

async function getOrPromptForBundleIdentifier(projectRoot) {
  var _exp$ios;

  let {
    exp
  } = (0, _config().getConfig)(projectRoot);

  if ((_exp$ios = exp.ios) === null || _exp$ios === void 0 ? void 0 : _exp$ios.bundleIdentifier) {
    return exp.ios.bundleIdentifier;
  } // TODO: add example based on slug or name


  (0, _log().default)(`Now we need to know your ${(0, _terminalLink().default)('iOS bundle identifier', 'https://expo.fyi/bundle-identifier')}. You can change this in the future if you need to.`);
  const {
    bundleIdentifier
  } = await (0, _prompt().default)([{
    name: 'bundleIdentifier',
    message: `What would you like your bundle identifier to be?`,
    validate: value => /^[a-zA-Z][a-zA-Z0-9\-.]+$/.test(value)
  }]);

  _log().default.newLine();

  return bundleIdentifier;
}

async function getOrPromptForPackage(projectRoot) {
  var _exp$android;

  let {
    exp
  } = (0, _config().getConfig)(projectRoot);

  if ((_exp$android = exp.android) === null || _exp$android === void 0 ? void 0 : _exp$android.package) {
    return exp.android.package;
  } // TODO: add example based on slug or name


  (0, _log().default)(`Now we need to know your ${(0, _terminalLink().default)('Android package', 'https://expo.fyi/android-package')}. You can change this in the future if you need to.`);
  const {
    packageName
  } = await (0, _prompt().default)([{
    name: 'packageName',
    message: `What would you like your package to be named?`,
    validate: value => /^[a-zA-Z][a-zA-Z0-9\-.]+$/.test(value)
  }]);

  _log().default.newLine();

  return packageName;
}

async function mergeGitIgnoreAsync(targetGitIgnorePath, sourceGitIgnorePath) {
  if (!_fsExtra().default.existsSync(targetGitIgnorePath)) {
    // No gitignore in the project already, no need to merge anything into anything. I guess they
    // are not using git :O
    return;
  }

  if (!_fsExtra().default.existsSync(sourceGitIgnorePath)) {
    // Maybe we don't have a gitignore in the template project
    return;
  }

  let targetGitIgnore = _fsExtra().default.readFileSync(targetGitIgnorePath).toString();

  let sourceGitIgnore = _fsExtra().default.readFileSync(sourceGitIgnorePath).toString();

  let mergedGitIgnore = `${targetGitIgnore}
# The following contents were automatically generated by expo-cli during eject
# ----------------------------------------------------------------------------

${sourceGitIgnore}`;

  _fsExtra().default.writeFileSync(targetGitIgnorePath, mergedGitIgnore);
}
/**
 * Some packages are not configured automatically on eject and may require
 * users to add some code, eg: to their AppDelegate.
 */


async function warnIfDependenciesRequireAdditionalSetupAsync(projectRoot) {
  // We just need the custom `nodeModulesPath` from the config.
  const {
    exp,
    pkg
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });
  const pkgsWithExtraSetup = await _jsonFile().default.readAsync((0, _config().resolveModule)('expo/requiresExtraSetup.json', projectRoot, exp));
  const packagesToWarn = Object.keys(pkg.dependencies).filter(pkgName => pkgsWithExtraSetup.hasOwnProperty(pkgName));

  if (packagesToWarn.length === 0) {
    return;
  }

  _log().default.newLine();

  let warnAdditionalSetupStep = logNewSection('Checking if any additional setup steps are required for installed SDK packages.');
  let plural = packagesToWarn.length > 1;
  warnAdditionalSetupStep.stopAndPersist({
    symbol: '‚ö†Ô∏è ',
    text: _chalk().default.red(`Your app includes ${_chalk().default.bold(`${packagesToWarn.length}`)} package${plural ? 's' : ''} that require${plural ? '' : 's'} additional setup in order to run:`)
  });
  packagesToWarn.forEach(pkgName => {
    _log().default.nested(`- ${_chalk().default.bold(pkgName)}: ${pkgsWithExtraSetup[pkgName]}`);
  });
}

function stripDashes(s) {
  return s.replace(/\s|-/g, '');
}
//# sourceMappingURL=../../__sourcemaps__/commands/eject/Eject.js.map
